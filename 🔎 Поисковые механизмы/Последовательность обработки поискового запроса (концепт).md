Получаем исходный поисковый запрос
==================================

Получаем исходный поисковый запрос (так, как его ввёл пользователь) и параметры поиска из браузера пользователя

Сохраняем данные поискового запроса в БД
========================================

Цель — последующий анализ поисковых запросов и совершенствование поиска.

Нормализуем текст
=================

См. [Нормализация и фильтрация текстовых данных](#TODO)

Пример

* поисковый запрос на входе: ` Инженер-конструктор ,( !AutoCad |AutoDesc ) ; / " банкоматы уличные " ------------ 1%#@^. -nanoCad   `
* поисковый запрос на выходе: `Инженер-конструктор, (!AutoCad | AutoDesc); / "банкоматы уличные " --- 1%#@^. -nanoCad`

Минимальная автотипографика с пробельными символами для улучшения читабельности
===============================================================================

1.  Удаляем символы-дубликаты: подряд идущий 4-й и далее символ, кроме букв, цифр и знаков `[()]`
2.  Удаляем пробелы перед символом `[:]`
3.  Обрамляем пробелами символ `[|]`
4.  Вставляем пробел перед символами `[` `/\]`, если за ними есть пробел
5.  Вставляем пробел после символов `[` `/\]` , если перед ними есть пробел
6.  Вставляем пробел перед символами `[«(]` и удаляем после
7.  Удаляем пробелы перед символами `[»)]` и вставляем после
8.  Вставляем пробел перед нечётными `["]` и удаляем после
9.  Удаляем пробелы перед чётными `["]` и вставляем после
10. Удаляем пробелы перед символами `[,;]` и вставляем после (если до и после запятой не цифра)

В браузере пользователя в поле ввода поискового запроса заменяем исходный текст на нормализованный, заменяем однозначно исправленные слова, в которых были ошибки/опечатки. Под полем ввода поискового запроса предлагаем пользователю варианты исправлений для неоднозначных слов (показываем исходные и исправленные слова). Ориентируемся на функциональность, реализованную в Яндекс.

Пример

```js
//поисковый запрос на входе: [пилотттттт смолёта ТУ-154, Боинг747]
 
//массив токенов
var tokens = [
    {token: 'word',  value: 'пилотттттт'},
    {token: 'other', value: ' '},
    {token: 'word',  value: 'смолёта'},
    {token: 'other', value: ' ТУ-154, '},
    {token: 'word',  value: 'Боинг'},
    {token: 'other', value: '747'},
];
 
//поисковый запрос на выходе: [пилот самолёта ТУ-154, Боинг 747]
```

Токенизируем поисковый запрос в дерево
======================================

Предварительная обработка запроса:

1.  Заменяем кавычки-ёлочки на обычные кавычки.
2.  Удаляем вложенные кавычки.
3.  Удаляем слова-дубликаты: подряд идущее 4-е и слово и далее

Токенизируем поисковый запрос и строим дерево поискового контекста с учётом языка поисковых запросов.

Рассматриваем символы `,;/\`  как разделители именованных сущностей для улучшения качества их распознавания.

```js
//поисковый запрос: [начальник, закупки оборудования (канцтовары | !комус) от 50 000 -Макдоналдс -!секретарь -офис-менеджер]
 
//двумерный массив обособленных последовательностей токенов
var tokensSequences = [
    ['начальник'],
    ['закупки', 'оборудования'],
    ['канцтовары'],
    ['комус'],
    [50000],
    ['Макдоналдс'],
    ['секретарь'],
    ['офис', 'менеджер'],
];
 
//словарь синонимов и англоязычных/русскоязычных альтернатив
var tokensSynonyms = {
    'начальник'  : 'руководитель',
    'канцтовары' : 'канцелярские товары',
    'комус'      : 'Komus',
    'Макдоналдс' : 'McDonalds',
    'секретарь'  : 'помошник руководителя',
};
 
//дерево условий поиска по токенам
var tokensConditions =
{and: [
    {token: 'word', value: 'начальник'},
    {token: 'word', value: 'закупки'},
    {token: 'word', value: 'оборудования'},
    {or: [
        {token: 'word', value: 'канцтовары'},
        {phrase: [
            {token: 'word', value: 'комус'},
        ]},
    ]},
    {token: 'operator', value: '>='},
    {token: 'float', value: 50000},
    {not: [
        {token: 'word', value: 'Макдоналдс'},
    ]},
    {not: [
        {phrase: [
            {token: 'word', value: 'секретарь'},
        ]},
    ]},
    {not: [
        {sequence: [
            {token: 'word', value: 'офис'},
            {token: 'word', value: 'менеджер'},
        ]},
    ]},
]};
```

Пример 2

```js
//поисковый запрос: [ищу работу ночальником закупки оборудования, но не канцтоваров (НЕ АХО!) и не компьютеров]
//двумерный массив обособленных последовательностей токенов
 
//дерево условий поиска по токенам
//стоп-слова "но", "и" нужно игнорировать при канонизации запроса
//последовательность токенов "ищу", "работу" на шаге определения сущностей должна определиться как маркер поиска вакансий
var tokensConditions =
{and: [
    {token: 'word', value: 'ищу'},
    {token: 'word', value: 'работу'},
    {token: 'word', value: 'ночальником'},
    {token: 'word', value: 'закупки'},
    {token: 'word', value: 'оборудования'},
    {not: [
        {token: 'word', value: 'канцтоваров'},
    ]},
    {not: [
        {token: 'word', value: 'АХО'},
    ]},
    {not: [
        {token: 'word', value: 'компьютеров'},
    ]},
]};
```
  

Расширяем слова синонимами и альтернативами
===========================================

TODO

Извлекаем именованные сущности
==============================

При извлечении сущностей могут возникнуть неоднозначности (они же коллизии).

Виды коллизий в гео:

1.  Коллизия найдена в одном справочнике: 
    1.  Одно метро в разных городах: Чкаловская — метро в Москве, Санкт-Петербурге, Екатеринбурге и Нижнем Новгороде.
    2.  Один город в разных регионах
2.  Коллизия найдена в разных справочниках: 
    1.  Город или метро: Сокол

Для решения неоднозначности необходимо учитывать текущее местоположение пользователя.

TODO - это свалка, которую нужно разобрать:
<blockquote>

  Примеры поисковых запросов: `охранник на вахту в московский офис Макдоналдс`, `программист java, spring`

  В браузере пользователя под полем ввода поискового запроса показываем описание запроса для лучшего понимания, как работает поиск. Все условия поиска нужно написать по-русски. Пример:

  **Поисковый запрос:** `начальник, закупки оборудования (канцтовары | комус) от 50 000 -Макдоналдс -!секретарь -офис-менеджер`

  **Описательный запрос:** найти документы, содержащие слова:  `начальник  _и_  закупки  _и_  оборудования (канцтовары  _или_  комус)`  c  зарплатой от 50,000 рублей

  исключить документы, содержащие слова:   `компания:Макдоналдс  _или_  "секретарь"  _или_  офис-менеджер`

  **Исходный запрос (пример):** `начальник, закупки оборудования (канцтовары | комус) от 50 000 -Макдоналдс -!секретарь -офис-менеджер`

  ~Приводим к лемме (базовой словоформе) все слова, которые не нужно искать в заданной словоформе.~ (пока рано)
</blockquote>  

Учёт географического местоположения (гео) в ранжировании
========================================================

* [Geo spatial in Sphinx (in PDF)](https://www.percona.com/live/london-2013/sites/default/files/slides/Fulltext%2520engine%2520for%2520non-fulltext%2520searches_0.pdf)
* [How can you find the centroid of a concave irregular polygon in JavaScript?](https://stackoverflow.com/questions/9692448/how-can-you-find-the-centroid-of-a-concave-irregular-polygon-in-javascript)
    

Для извлечённой сущности "местоположение" (город, район) из геосправочника получаем координаты: широту/долготу точки на карте или массив координат области на карте (он же многоугольник / полигон). Для области получаем так же [центроид](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D1%80%D0%B8%D1%86%D0%B5%D0%BD%D1%82%D1%80) (он же барицентр).

TODO
====

Нужно дать примеры реальных запросов, где используется запятая в качестве условия "и" и "или".

[https://regex101.com/r/IIxRix/2/](https://regex101.com/r/IIxRix/2/) — рег. выражение для шаблона`профессия+метро`

В названиях профессий часть встречаются другие сущности, например:`[И.о. руководителя продаж в Лагосе (Нигерия)]`.  
Поэтому нужно делать нормализацию данных на этапе индексирования резюме для поиска.

Карты с полигонами:

* [https://www.openstreetmap.org/](https://www.openstreetmap.org/)  
    
* [http://www.naturalearthdata.com](http://www.naturalearthdata.com/)  
    

Полезные ссылки

1.  [https://docs.mongodb.com/v3.4/reference/sql-comparison/](https://docs.mongodb.com/v3.4/reference/sql-comparison/)
2.  [http://sphinxsearch.com/docs/current.html#sphinxql-call-keywords](http://sphinxsearch.com/docs/current.html#sphinxql-call-keywords) — returns tokenized and normalized forms of the keywords
3.  [https://www.postgresql.org/docs/11/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES](https://www.postgresql.org/docs/11/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES)— парсер поискового запроса в PostgreSQL 11
