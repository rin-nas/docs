# Уровни изоляции PostgreSQL

Эта страница дополняет официальную документацию PostgreSQL в части страницы "[Изоляция транзакций](https://postgrespro.ru/docs/postgresql/current/transaction-iso)".

| №  | Level               | Уровень                         | Область видимости снимка данных | Описание
| :- | :------------------ | :------------------------------ | :-------------------------------| :-------
| 1  | ~~Read uncommited~~ | Чтение незафиксированных данных | Строка таблицы | Можно увидеть изменения незавершённых транзакций.<br /> Уровень отсутствует в PostgreSQL.
| 2  | Read commited       | Чтение зафиксированных данных   | Запрос         | Можно увидеть изменения только завершённых транзакций
| 3  | Repeatable read     | Повторяемое чтение              | Транзакция     | То, что прочитано однажды, будет прочитано ещё раз
| 4  | Serializable        | Сериализуемость                 | Транзакция     | Полная иллюзия последовательного выполнения, в частности, отсутствие неожиданно появляющихся строк

# Примеры ошибок read commited

<table>
  <tr>
    <th>Сценарий</th>
    <th>Проблема</th>
    <th>Причина</th>
    <th>Решение</th>
  </tr>
  <tr>
    <td>Комментарии к посту.</td>
    <td>Иногда при добавлении комментария возникает нарушение внешнего ключа.</td>
    <td>Пост был удален после начала транзакции, добавляющей комментарий.</td>
    <td>Варианты:
      <ol>
        <li>Блокировать пост (for share/for update)</li>
        <li>Поставить нужный уровень изоляции</li>
      </ol>
    </td>
  </tr>
  <tr>
    <td>Двойные выплаты. Две таблицы: client(id), client_payment(id, client_id)</td>
    <td>Одному клиенту было направлено две выплаты.</td>
    <td>Две одновременно работающих транзакции не нашли произведенных выплат payment</td>
    <td>Варианты:
      <ol>
        <li>Блокировать клиента (for update/for share)</li>
        <li>Уникальный ключ на client_payment(client_id)</li>
        <li>Поставить нужный уровень изоляции</li>
      </ol>
    </td>
  </tr>
  <tr>
    <td>
      <p>Таблица <code>balance(user_id, acc_no, amt, flag)=[(1,1,99,false),[1,2,100,false])</code></p>
      <p>Транзакция 1: <code>update balance set amt=amt+1 where user_id=1</code></p>
      <p>Транзакция 2: <code>update balance set flag=<strong>true</strong> where user_id=1 and amt=100</code></p>
    </td>
    <td><code>balance(user_id, acc_no, amt, flag)=[(1,1,100,<strong>false</strong>),[1,2,101,<strong>false</strong>])</code></td>
    <td>Потому что в при изменении данных при поиске подходящих строк сначала читаются старые значения и используются в вычислении условия, 
      а потом, непосредственно при обновлении, <ins>после получения блокировки</ins>, условия перепроверяются: первая строка пропущена, потому что прочитано 99, а вторая — потому что после получения блокировки она уже 101</td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>

|  |  | 


## Ссылки по теме

1. [Уровни изоляции транзакций с примерами на PostgreSQL](https://habr.com/ru/articles/317884/)
